################################################################################
# DataSHIELD GHA test suite - dsBase (curated refs matrix version)
# Now supports testing curated branches/tags from .github/dsbase-refs.txt
################################################################################
name: dsBase tests' suite

on:
  push:
  schedule:
    - cron: '0 0 * * 0'   # weekly
    # - cron: '0 1 * * *'   # nightly
  workflow_dispatch:

env:
  TARGET_REPOSITORY: datashield/dsBase
  PROJECT_NAME: dsBase

jobs:
  set-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.build.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4

      - name: Build matrix from LABEL=REF file (.github/dsbase-refs.txt)
        id: build
        run: |
          if [ ! -f .github/dsbase-refs.txt ]; then
            echo "ERROR: .github/dsbase-refs.txt not found."
            exit 1
          fi

          FILE=".github/dsbase-refs.txt"

          MATRIX_JSON=$(grep -v '^\s*#' "$FILE" | grep -v '^\s*$' | awk -F= '
            {
              label=$1
              ref=$2
              gsub(/^[ \t]+|[ \t]+$/, "", label)
              gsub(/^[ \t]+|[ \t]+$/, "", ref)
              printf "{\"label\":\"%s\",\"ref\":\"%s\"}\n", label, ref
            }
          ' | jq -s -c '.')

          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

  dsBase_test_suite:
    needs: set-matrix
    runs-on: ubuntu-latest
    timeout-minutes: 120
    permissions:
      contents: write

    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.set-matrix.outputs.matrix) }}

    env:
      TEST_FILTER: '*'
      _r_check_system_clock_: 0
      REF_NAME: ${{ matrix.ref }}
      REF_LABEL: ${{ matrix.label }}
      WORKFLOW_ID: ${{ github.run_id }}-${{ github.run_attempt }}-${{ matrix.ref }}

    steps:
      - name: Checkout dsTestsDashboard
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout dsBase
        uses: actions/checkout@v4
        with:
          repository: ${{ env.TARGET_REPOSITORY }}
          token: ${{ github.token }}
          ref: ${{ matrix.ref }}
          fetch-depth: 0
          path: dsBase

      - uses: r-lib/actions/setup-pandoc@v2

      - uses: r-lib/actions/setup-r@v2
        with:
          r-version: release
          use-public-rspm: true

      - uses: r-lib/actions/setup-r-dependencies@v2
        with:
          working-directory: dsBase
          dependencies: '"Imports"'
          needs: check
          cache-version: 1
          extra-packages: |
            cran::devtools
            cran::usethis

      - name: Devtools check
        run: |
          R -q -e "devtools::check(args = c('--no-tests','--no-examples'))"
        working-directory: dsBase
        continue-on-error: false

      - name: Install dsBase explicitly
        run: |
          echo "Installing dsBase after check"
          R -e "devtools::install('.')"
        working-directory: dsBase

      - name: Run tests and generate coverage report
        working-directory: dsBase
        continue-on-error: false
        run: |
          Rscript -e '
            out_dir <- file.path(getwd(), "logs");
            dir.create(out_dir, recursive = TRUE, showWarnings = FALSE);

            devtools::reload();
            library(dsBase);

            # define output paths
            test_results_xml <- file.path(out_dir, "test_results.xml");
            coverage_csv <- file.path(out_dir, "coveragelist.csv");
            coverage_xml <- file.path(out_dir, "coverage.xml");

            cat("=== Running testthat directly (debug mode) ===\n");
            cat("Working directory:", getwd(), "\n");
            cat("R version:", R.version.string, "\n");
            cat("Writing outputs to: ", out_dir, "\n");

            # run tests using testthat and save results to XML
            tryCatch({
              library(testthat);
              junit_rep <- testthat::JunitReporter$new(file = test_results_xml);
              progress_rep <- testthat::ProgressReporter$new(max_failures = 999999);
              multi_rep <- testthat::MultiReporter$new(reporters = list(progress_rep, junit_rep));
              testthat::test_dir("tests/testthat", filter = Sys.getenv("TEST_FILTER"), reporter = multi_rep, stop_on_failure = FALSE);
            }, error = function(e) {
              message("[ERROR] Testing: ", e);
            });

            # calculate coverage and write to CSV
            tryCatch({
              library(covr);
              coverage_result <- covr::package_coverage(type = c("tests"), quiet = FALSE);
              coverage_list <- covr::coverage_to_list(coverage_result);
              write.csv(coverage_list, coverage_csv, row.names = FALSE);

              # generate coverage xml to be push to Codecov
              covr::to_cobertura(coverage_result, coverage_xml)
            }, error = function(e) {
              message("[ERROR] Code coverage: ", e);
            });
          '
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          working-directory: dsBase
          files: logs/coverage.xml
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload test results to Codecov
        if: ${{ !cancelled() }}
        uses: codecov/codecov-action@v5
        with:
          report_type: test_results
          working-directory: dsBase
          files: logs/test_results.xml
          token: ${{ secrets.CODECOV_TOKEN }}

      # - name: Publish Test Report
      #   uses: dorny/test-reporter@v1
      #   if: always()
      #   with:
      #     name: R testthat results
      #     path: dsBase/logs/test_results.xml
      #     reporter: java-junit

      - name: Write versions to file
        run: |
          echo "ref:${{ env.REF_NAME }}" > ${{ env.WORKFLOW_ID }}.txt
          echo "ref_label:${{ env.REF_LABEL }}" >> ${{ env.WORKFLOW_ID }}.txt
          echo "os:$(lsb_release -ds)" >> ${{ env.WORKFLOW_ID }}.txt
          echo "R:$(R --version | head -n1)" >> ${{ env.WORKFLOW_ID }}.txt
          Rscript --vanilla -e 'sessionInfo()' >> session_info_${{ env.WORKFLOW_ID }}.txt
        working-directory: dsBase/logs

      - name: Upload logs artefact
        uses: actions/upload-artifact@v4
        with:
          name: logs-ref_${{ matrix.ref }}-label_${{ matrix.label }}
          path: dsBase/logs
          if-no-files-found: error

      - name: Dump environment (on failure)
        if: failure()
        run: |
          echo -e "\n#############################"
          echo -e "ls /: ######################"
          ls -al .
          echo -e "\n#############################"
          echo -e "lscpu: ######################"
          lscpu
          echo -e "\n#############################"
          echo -e "memory: #####################"
          free -m
          echo -e "\n#############################"
          echo -e "env: ########################"
          env
          echo -e "\n#############################"
          echo -e "R sessionInfo(): ############"
          R -e 'sessionInfo()'
          sudo apt install tree -y
          tree .

  publish-results:
    name: Publish aggregated results
    needs: dsBase_test_suite
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout dsTestsDashboard
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artefacts
        uses: actions/download-artifact@v4
        with:
          path: artefacts

      - name: Merge artefacts into dashboard structure
        run: |
          set -e

          echo "Artefacts downloaded:"
          ls -R artefacts || true

          for dir in artefacts/logs-*; do
            if [ -d "$dir" ]; then
              BASENAME=$(basename "$dir")

              # extract ref (between logs-ref_ and -label_)
              REF="${BASENAME#logs-ref_}"
              REF="${REF%%-label_*}"

              # extract label (after -label_)
              LABEL="${BASENAME#*-label_}"

              echo "Processing:"
              echo "  ref:   $REF"
              echo "  label: $LABEL"

              WORKFLOW_ID="${{ github.run_id }}-${{ github.run_attempt }}-${REF}"
              TARGET_DIR="logs/${{ env.PROJECT_NAME }}/${LABEL}/${WORKFLOW_ID}/"
              mkdir -p "$TARGET_DIR"
              cp -rv "$dir"/* "$TARGET_DIR" || true
            fi
          done
        env:
          PROJECT_NAME: ${{ env.PROJECT_NAME }}

      - name: Commit and push once
        run: |
          rm -rf artefacts

          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"

          # rebase instead of pull to avoid merge commits
          git pull --rebase origin main || true

          git add .

          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git commit -m "Aggregated dsBase results @ ${{ github.run_id }}-${{ github.run_attempt }}"
          git push origin main
